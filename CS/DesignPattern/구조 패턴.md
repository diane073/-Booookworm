# 구조패턴 :

### 어댑터, 브릿지, 복합체, 데코레이터, 퍼사드, 플라이웨이트, 프록시

...

---

---

# Adaptor pattern

래퍼 Wrapper, Adaptor로도 불린다.

어댑터는 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴

_예시1_

> 자동차 <-> 레일은 서로 호환되지 않는데, 자동차를 실어 레일에서 옮길 수 있도록 하는 객차(어댑터)를 달아 운행하도록 할 수 있다.

_예시2_

> **문제상황** :
> 주식 시장 모니터링 앱 - 여러 소스에서 주식 데이터를 XML형식으로 다운로드, 사용자에게 보기 좋은 차트, 다이어그램 등을 표시하는 것이 목적일때, 기존 앱에 타사의 마트 분석 라이브러리를 적용하기로 했는데 JSON 데이터로만 작동하는 경우...
>
> > [ 주식데이터(XML) - 앱[핵심클래스](XML) - 분석 라이브러리(JSON) ]
> > 라이브러리를 XML과 작동할 수 있도록 변경할 수 있지만, 이 경우 라이브러리에 의존성을 가지는 코드가 손상될 수 있다. 처음부터 라이브러리 소스코드에 접근하는 것이 불가능하여 위의 해결 방식이 사용 불가능할 수도 있다.

> **해결책** :
> 이 경우 사용하는 것이 adaptor
> 한 객체의 인터페이스를 다른 객체가 이해할 수 있도록 변환하는 특별한 객체이다. 변환의 복잡성을 숨기기 위해 객체 중 하나를 래핑(포장)한다. 래핑 객체는 어댑터를 인식하지도 못함(= 어댑터는 알아서 따로 기능).
> 어댑터는 데이터 형식 변환, 다른 인터페이스를 가진 객체들의 협업에 이용할 수 있다.

> _작동방식_
>
> > [ 주식데이터(XML) - 앱[핵심클래스](XML) - " (XML)[XML->JSON 어댑터](JSON) " - 분석 라이브러리(JSON) ]

모든 클래스에 대한 XML->JSON 변환 어댑터를 만든다.
이후 이러한 어댑터들을 통해서만 해당 라이브러리와 통신하도록 코드를 조정한다.

...

---

# Decorator pattern

https://refactoring.guru/ko/design-patterns/decorator

데코레이터는
새로운 행동을 포함한 특수 래퍼 객체들 내에 객체들을 넣어 행동을 객체와 연결시키는 구조적 디자인 패턴이다.

마치 양파 / 마트료시카와 같이 감싸고 감싸며 연결하는 느낌

> **문제상황** :
> 알림 라이브러리를 만들고 있다고 가정,
> 다른 프로그램이 사용자자들에게 중요한 이벤트를 알릴 수 있도록 하는 것이 목적이다.
>
> > [알림 라이브러리 Notifier] <- aplication
>
> 사용자들이 이메일 알림 외에도 sms, facebook slack 등 다른 알림을 받고싶어하는 경우, Notifier 클래스를 확장할 수 있다. 추가 알림 메서드들을 Notifier의 자식클래스에 넣어 인스턴스화할 수 있다. 그런데 누군가 여러 유형의 알림을 사용하고 싶다는 의견을 보낼 경우 sms+facebook, sms+slack, slack+facbook 등의 자식 클래스를 추가해야할 것이다.

= 비효율적
= 상속은 정적이며, 자식클래스는 하나의 부모클래스만 가질 수 있다.

> **해결방법** :
> 따라서 집합관계, 합성을 사용하면 된다.
>
> - 집합 : 객체 A는 객체 B를 포함. B는 A 없이 생존 가능
> - 합성 : 객체 A는 객체 B로 구성. A는 B의 수명 주기를 관리함. B는 A없이 생존할 수 없음
>   둘은 거의 같은 방식으로 동작함. : 집합에서는 한 객체가 다른 객체에 대한 _참조를 가지고_ 일부 작업을 위임하는 반면, 합성을 사용하면 객체 자체가 부모 클래스에서 행동을 상속하고 해당 작업을 수행할 수 있다.

> 상속 :
> [자식] --> [부모]
>
> ........ [자식] ⏌

> 집합 :
> [클라이언트] ㅁ-> [서비스]

데코레이터를 사용하면 연결된 "도우미" 객체를 다른 객체로 쉽게 대체하여 런타임 때 컨테이너의 행동을 변경할 수 있다.

'래퍼'는 패턴의 주요 아이디어를 명확하게 표현하는 데코레이터 패턴의 별명

래퍼(간단한 데코레이터)는 자신이 받는 모든 요청을 대상 객체에 위임하는데, 요청을 대상에 전달하기 전이나 후에 무언가를 수행하여 결과를 변경할 수 있다.

래퍼는 래핑된 객체와 같은 인터페이스를 구현한다. 그러므로 클라이언트의 관점에서 이러한 객체들은 같게 보인다. 래퍼의 참조 필드가 해당 인터페이스를 따르는 모든 객체를 받도록 하면, 여러 래퍼로 객체를 포장해서 모든 래퍼들의 합성된 행동들을 객체에 추가할 수 있다,

다양한 알림메서드들이 데코레이터가 된다.
[Notifier] <- [BaseDecorator] <---== [SMS / FACEBOOK / SLACK Decorator]

클라이언트의 요청과 일치하는 데코레이터 집합으로 래핑해주어야하므로 객체들은 스택으로 구성되게 된다. 스택의 마지막 데코레이터는 실제 클라이언트와 작업하는 객체이다. 모든 데코레이터들은 기초 알림자같은 인터페이스를 구현하므로 이후 작동에 대해 상관하지 않는다.

```
stack = new Notifier()
if (facebookEnabled)
    stack = new FacebookDecorator(stack)
if (slackEnabled)
    stack = new SlackDecorator(stack)

app.setNotifier(stack)
```

메시지 형식 지정 또는 수신자 리스트 작성과 같은 다른 행동들에도 같은 접근 방식을 적용할 수 있다.

> 실생활 예) 여러 벌의 옷을 입으면 복합 효과를 얻을 수 있습니다.
